package org.eclipse.ceylon.compiler.java.test.expression.operator;

class RangeOp<T> implements .org.eclipse.ceylon.compiler.java.runtime.model.ReifiedType, .java.io.Serializable {
    
    RangeOp(final .org.eclipse.ceylon.compiler.java.runtime.model.TypeDescriptor $reified$T) {
        this.$reified$T = $reified$T;
    }
    private final .org.eclipse.ceylon.compiler.java.runtime.model.TypeDescriptor $reified$T;
    
    private final void int$priv$(final long i1, final long i2) {
        final .ceylon.language.Range<.ceylon.language.Integer> range = .ceylon.language.span_.<.ceylon.language.Integer>span(.ceylon.language.Integer.$TypeDescriptor$, .ceylon.language.Integer.instance(i1), .ceylon.language.Integer.instance(i2));
    }
    
    private final <T extends .ceylon.language.Enumerable<T>>void t$priv$(final .org.eclipse.ceylon.compiler.java.runtime.model.TypeDescriptor $reified$T, final T t1, final T t2) {
        final .ceylon.language.Range<T> range = .ceylon.language.span_.<T>span($reified$T, (T)t1, (T)t2);
    }
    
    @.java.lang.Override
    public .org.eclipse.ceylon.compiler.java.runtime.model.TypeDescriptor $getType$() {
        return .org.eclipse.ceylon.compiler.java.runtime.model.TypeDescriptor.klass(.org.eclipse.ceylon.compiler.java.test.expression.operator.RangeOp.class, $reified$T);
    }
}
abstract class RangeOpEnum implements .org.eclipse.ceylon.compiler.java.runtime.model.ReifiedType, .ceylon.language.Enumerable<.org.eclipse.ceylon.compiler.java.test.expression.operator.RangeOpEnum>, .java.io.Serializable {
    
    RangeOpEnum() {
        this.$ceylon$language$Enumerable$this$ = new .ceylon.language.Enumerable$impl<.org.eclipse.ceylon.compiler.java.test.expression.operator.RangeOpEnum>(.org.eclipse.ceylon.compiler.java.test.expression.operator.RangeOpEnum.$TypeDescriptor$, this);
    }
    protected final .ceylon.language.Enumerable$impl<.org.eclipse.ceylon.compiler.java.test.expression.operator.RangeOpEnum> $ceylon$language$Enumerable$this$;
    
    @.java.lang.Override
    public .ceylon.language.Enumerable$impl<.org.eclipse.ceylon.compiler.java.test.expression.operator.RangeOpEnum> $ceylon$language$Enumerable$impl() {
        return $ceylon$language$Enumerable$this$;
    }
    
    @.java.lang.Override
    public long offsetSign(final .org.eclipse.ceylon.compiler.java.test.expression.operator.RangeOpEnum other) {
        return $ceylon$language$Enumerable$this$.offsetSign(other);
    }
    
    @.java.lang.Override
    public .org.eclipse.ceylon.compiler.java.test.expression.operator.RangeOpEnum getPredecessor() {
        return (.org.eclipse.ceylon.compiler.java.test.expression.operator.RangeOpEnum)$ceylon$language$Enumerable$this$.getPredecessor();
    }
    
    @.java.lang.Override
    public .org.eclipse.ceylon.compiler.java.test.expression.operator.RangeOpEnum getSuccessor() {
        return (.org.eclipse.ceylon.compiler.java.test.expression.operator.RangeOpEnum)$ceylon$language$Enumerable$this$.getSuccessor();
    }
    
    @.java.lang.Override
    public final long offset(final .org.eclipse.ceylon.compiler.java.test.expression.operator.RangeOpEnum other) {
        return this == other ? 0L : 1L;
    }
    
    @.java.lang.Override
    public final .org.eclipse.ceylon.compiler.java.test.expression.operator.RangeOpEnum neighbour(final long offset) {
        return (.org.eclipse.ceylon.compiler.java.test.expression.operator.RangeOpEnum)(!(offset % 2L == 0L == (this == .org.eclipse.ceylon.compiler.java.test.expression.operator.rangeOpE_.get_())) ? .org.eclipse.ceylon.compiler.java.test.expression.operator.rangeOpF_.get_() : .org.eclipse.ceylon.compiler.java.test.expression.operator.rangeOpE_.get_());
    }
    
    @.java.lang.Override
    public .org.eclipse.ceylon.compiler.java.runtime.model.TypeDescriptor $getType$() {
        return .org.eclipse.ceylon.compiler.java.test.expression.operator.RangeOpEnum.$TypeDescriptor$;
    }
    public static final .org.eclipse.ceylon.compiler.java.runtime.model.TypeDescriptor $TypeDescriptor$ = .org.eclipse.ceylon.compiler.java.runtime.model.TypeDescriptor.klass(.org.eclipse.ceylon.compiler.java.test.expression.operator.RangeOpEnum.class);
}
final class rangeOpF_ extends .org.eclipse.ceylon.compiler.java.test.expression.operator.RangeOpEnum implements .java.io.Serializable {
    
    private rangeOpF_() {
        super();
    }
    
    private .java.lang.Object readResolve() {
        return .org.eclipse.ceylon.compiler.java.test.expression.operator.rangeOpF_.get_();
    }
    public static final .org.eclipse.ceylon.compiler.java.runtime.model.TypeDescriptor $TypeDescriptor$ = .org.eclipse.ceylon.compiler.java.runtime.model.TypeDescriptor.klass(.org.eclipse.ceylon.compiler.java.test.expression.operator.rangeOpF_.class);
    private static final .org.eclipse.ceylon.compiler.java.test.expression.operator.rangeOpF_ $object$;
    private static volatile boolean $init$$object$ = false;
    private static final .java.lang.Throwable $initException$;
    static {
        try {
            $object$ = new .org.eclipse.ceylon.compiler.java.test.expression.operator.rangeOpF_();
            .org.eclipse.ceylon.compiler.java.test.expression.operator.rangeOpF_.$init$$object$ = true;
            $initException$ = null;
        } catch (.java.lang.Throwable x) {
            $initException$ = x;
            $object$ = null;
            .org.eclipse.ceylon.compiler.java.test.expression.operator.rangeOpF_.$init$$object$ = false;
        }
    }
    
    static .org.eclipse.ceylon.compiler.java.test.expression.operator.rangeOpF_ get_() {
        if (.org.eclipse.ceylon.compiler.java.test.expression.operator.rangeOpF_.$init$$object$) {
            return .org.eclipse.ceylon.compiler.java.test.expression.operator.rangeOpF_.$object$;
        } else {
            if ($initException$ != null) .org.eclipse.ceylon.compiler.java.Util.rethrow($initException$);
            throw new .ceylon.language.InitializationError("Cyclic initialization trying to read the value of \'rangeOpF\' before it was set");
        }
    }
    
    @.java.lang.Override
    public .org.eclipse.ceylon.compiler.java.runtime.model.TypeDescriptor $getType$() {
        return .org.eclipse.ceylon.compiler.java.test.expression.operator.rangeOpF_.$TypeDescriptor$;
    }
}
final class rangeOpE_ extends .org.eclipse.ceylon.compiler.java.test.expression.operator.RangeOpEnum implements .java.io.Serializable {
    
    private rangeOpE_() {
        super();
    }
    
    private .java.lang.Object readResolve() {
        return .org.eclipse.ceylon.compiler.java.test.expression.operator.rangeOpE_.get_();
    }
    public static final .org.eclipse.ceylon.compiler.java.runtime.model.TypeDescriptor $TypeDescriptor$ = .org.eclipse.ceylon.compiler.java.runtime.model.TypeDescriptor.klass(.org.eclipse.ceylon.compiler.java.test.expression.operator.rangeOpE_.class);
    private static final .org.eclipse.ceylon.compiler.java.test.expression.operator.rangeOpE_ $object$;
    private static volatile boolean $init$$object$ = false;
    private static final .java.lang.Throwable $initException$;
    static {
        try {
            $object$ = new .org.eclipse.ceylon.compiler.java.test.expression.operator.rangeOpE_();
            .org.eclipse.ceylon.compiler.java.test.expression.operator.rangeOpE_.$init$$object$ = true;
            $initException$ = null;
        } catch (.java.lang.Throwable x) {
            $initException$ = x;
            $object$ = null;
            .org.eclipse.ceylon.compiler.java.test.expression.operator.rangeOpE_.$init$$object$ = false;
        }
    }
    
    static .org.eclipse.ceylon.compiler.java.test.expression.operator.rangeOpE_ get_() {
        if (.org.eclipse.ceylon.compiler.java.test.expression.operator.rangeOpE_.$init$$object$) {
            return .org.eclipse.ceylon.compiler.java.test.expression.operator.rangeOpE_.$object$;
        } else {
            if ($initException$ != null) .org.eclipse.ceylon.compiler.java.Util.rethrow($initException$);
            throw new .ceylon.language.InitializationError("Cyclic initialization trying to read the value of \'rangeOpE\' before it was set");
        }
    }
    
    @.java.lang.Override
    public .org.eclipse.ceylon.compiler.java.runtime.model.TypeDescriptor $getType$() {
        return .org.eclipse.ceylon.compiler.java.test.expression.operator.rangeOpE_.$TypeDescriptor$;
    }
}
final class bug_ {
    
    private bug_() {
    }
    
    static void bug() {
        final .ceylon.language.Range<.org.eclipse.ceylon.compiler.java.test.expression.operator.RangeOpEnum> range = .ceylon.language.span_.<.org.eclipse.ceylon.compiler.java.test.expression.operator.RangeOpEnum>span(.org.eclipse.ceylon.compiler.java.test.expression.operator.RangeOpEnum.$TypeDescriptor$, .org.eclipse.ceylon.compiler.java.test.expression.operator.rangeOpE_.get_(), .org.eclipse.ceylon.compiler.java.test.expression.operator.rangeOpF_.get_());
    }
}